title: 以太坊源码分析02-rlp part1
author: gsal
tags:
  - 以太坊
  - 区块链
  - java
categories:
  - 区块链
date: 2018-04-10 21:16:00
---
#### byte
在java中，整数有四种，byte，short，int，long，分别8、16、32、64位，而他们都是以补码形式保存的。  
补码的规则是：第一位为符号位，为0则正，为1则负，而0表示为0000 0000,1000 0000则表示最小数。  
原码求补码、补码求原码的规则是按位取反加1（只针对负数，正数不需转换）。补码有一个特点，符号位相同时，就算不看符号位也能比较出大小。如1000 0000与 1111 1111谁大？ 1111 1111大，不看符号位，很显然，看了符号位，知道这两个数都是负数，1000 0000实际上是-128,1111 1111实际上是-1，这也是我们为什么要引入补码的一个原因。  
所以当我们从int转到byte的时候，由于byte表示的范围只有-128到127，int中大于127的数到了byte中就变为了负数，下面这张图可谓一目了然。
<!--more-->
![1110 1000转为十进制为-24](/images/byte.png)

#### encoding
rlp有五种情况
1. 数据是单个字节并且是0-127范围内，那么原封不动  
如15->[15],127->[127]
1. 数据是0-55字节，那么128 + 数据的字节长度（最多128 + 55 = 183）作为encoding之后的第一个字节，后面就放数据的字节表示。如"abc"->[131,97,98,99]，因为abc三字节，字节表示为"97,98,99"，所以128 + 3 = 131，放在第一位
1. 数据大于55字节，那么就从183开始加，但是如果直接加数据的字节长度，就会太大了超过一个字节最大的255，因此就把数据拿过来先计算一个长度，比如说30，表示数据有30个字节，然后再算这个“30”有多长，那肯定一个字节就可以放下，所以就用183 + 1，最后就是[183,30,....]。
1. 对于数组，如果数组总的长度（每个元素都encoding后）在0-55字节，先对数组中每个元素进行encoding，然后把数组所有元素放在一起，把他们的长度加到192上面去。  
比如
["dog", "cat"]-> [200, 131, 100, 111, 103, 131, 99,97,116]
1. 如果数组总的长度（每个元素都encoding后）大于55字节，先对数组中每个元素进行encoding，然后把数组所有元素放在一起，总的encoding，算长度，然后把这个长度的长度加到247上面去。  
["this is a very long list", "you never guess how long it is", "indeed，how did you know it was this long", "good job, that I can tell you in honestlyyyyy"]
 ->  
 [248, 144, 152, 116, 104, 105, 115, 32, 105, 115, 32, 97, 32, 118,101, 114, 121, 32, 108, 111, 110, 103, 32, 108, 105, 115, 116, 158,121, 111, 117, 32, 110, 101, 118, 101, 114, 32, 103, 117, 101, 115,115, 32, 104, 111, 119, 32, 108, 111, 110, 103, 32, 105, 116, 32, 105 115, 169, 105, 110, 100, 101, 101, 100, 44, 32, 104, 111, 119, 32, 100,105, 100, 32, 121, 111, 117, 32, 107, 110, 111, 119, 32, 105, 116, 32,119, 97, 115, 32, 116, 104, 105, 115, 32, 108, 111, 110, 103, 173, 103,111, 111, 100, 32, 106, 111, 98, 44, 32, 116, 104, 97, 116, 32, 73, 32 99, 97, 110, 32, 116, 101, 108, 108, 32, 121, 111, 117, 32, 105, 110,32, 104, 111, 110, 101, 115, 116, 108, 121, 121, 121, 121, 121]
 
 
#### decoding
先看第一个字节，根据第一个字节所处的范围即可判断是哪种情况：    

|0-127|128-183|184-192|193-247|247-255|
|-|-|-|-|-|   
|单字节|1-55字节|56字节以上|数组1-55字节|数组56字节以上|
根据第一个字节的情况就可以判断第二个字节是数据还是长度的长度即可。不再赘述。

参考 http://hidskes.com/blog/2014/04/02/ethereum-building-blocks-part-1-rlp/
https://segmentfault.com/a/1190000011763339

#### &0xff
http://www.cnblogs.com/think-in-java/p/5527389.html
简单来说，&0xff为了从byte->int保持二进制表示的不变，即1000 0001 -> 0000 0000 1000 0001，而不是保持值的不变，也就是说将byte当成一个无符号数来看待。（java中byte是有符号的，从-127到128）