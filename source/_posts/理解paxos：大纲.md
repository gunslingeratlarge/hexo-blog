title: 理解paxos：大纲
author: gsal
tags:
  - 区块链
categories:
  - 区块链
date: 2018-04-03 16:48:00
---
https://understandingpaxos.wordpress.com/
# 一、介绍

- Paxos是分布式共识领域中最古老，最简单，最通用的算法之一
- 不建议通过阅读lamport的paxos made simple学习paxos，并不simple
- 对paxos核心算法以及它如何适应现有分布式计算的生态进行介绍
- 从以下三个层次展开
  - 从总体上：paxos是什么，在分布式系统中的位置
  - 解释paxos的工作原理并结合具体的冲突解决示例
  - 从局部上：阐释paxos的组成部分，解释他们的作用和责任
  - 除此之外，补充了paxos最常用的用例Multi-Paxos以及一些变种的介绍
<!--more-->

--

# 二、概览（Overview）

- paxos是什么
  - paxos是一种通过不可靠的沟通渠道达成单一价值共识的机制
- 在分布式系统中的角色
  - 一个原始的、可以构建更高层次抽象的构件
  - 独立于用例
  - 具有许多潜在应用的通用工具
- 如何运行
  - 定义了基于简单多数法则的对等一致协议
  - 协议能够确保达成一个单一的共识结果值
  - 所有的节点地位相当，没有谁的提议更有效或者更无效
- 失败容忍
  - 能够容忍正常故障，如机器崩溃和网络中断
  - 不能容忍恶意节点
  - 要求每个对等饭都必须遵守协议要求才可以保证正确性
- 不完整的规范
  - 基本算法只阐述了如何保证最终结果的正确性
  - 但还有许多方面的问题没有描述，如：
    - 如何保证最终结果一定能达到
    - 如何缓解节点间的干扰
    - 怎样保证所有节点都知晓最终结果
- 不完整规范的好处
  - 提供了巨大的灵活性
  - 开辟了广泛的潜在应用和优化的可能性
- 正确理解paxos的心态
  - 重点是各个组件以及它们之间的交互
  - 先从宏观上理解各个部分的作用，再了解细节
  - 可以将算法的各个部分分开来理解，它们的复杂性局限在各个部分内部
    - 正确性
    - 确保进展
    - 知晓最终结果
    - 延迟优化
    - 应用程序级逻辑

--

# 三、paxos的元素

- 提议ID
  - 通过提议ID可以判断消息的先后
  - 如(5，B)>(4,B)>(4，A)，5表示消息号，字母表示节点号
  - 新接受的消息的ID超过最后处理的消息，才对新消息进行处理
- 消息
  - 权限请求
    - 请求其他节点获得提出提议的许可
    - 被发送到所有的其他节点上
    - 包含：即将提出的提议的提议id
  - 许可授予
    - 如果收到权限请求的结点发现这条权限请求是最新的（id最大），那么发送许可授予
    - 包含
      - 对应的权限请求包含的提议id值
      - 最后接受的提议id
      - 最后接受的值
  - 提议
    - 获得多数节点的许可授予后，节点可以发送提议以企图在某个值上达成一致
    - 包含
      - 建议id
      - 值（blob二进制大文件）
  - 已接受
    - 如果接受对等方节点的提议，发送已接收消息来表示自己的接受态度
    - 包含：对应提议的提议id
  - 否定确认（Nack）
    - 如果不处理某个节点发来的消息，则发送Nack
    - Nack消息明确告知同伴他们的消息被忽略
    - 这样同伴可以尽早知道自己的消息无法达成多数条件，可以尽早提高消息id值

--

# 四、达成共识

- 基本步骤
  - 节点尝试发送请求许可消息
  - 获得许可之后，节点提出提议
- 消息处理规则
  - 收到权限请求消息
    - 必须为提议ID更大的消息授予权限
    - 更大：比自己之前批准过的权限请求消息更大
  - 收到提议消息
    - 必须接受提议Id更大的提议消息
    - 更大：比自己之前批准过的权限请求消息更大
    - 问题：假如最大批准了的是(3,A)，收到（6，B）的提议，接受提议，此时收到了(5,C)的权限请求消息，应如何处理？接受提议的时候会更新自己的已批准消息吗？（我觉得是会的，要不然还接受其他5,c的权限请求不成？）
- 其他注意事项
  - 即使达成共识，整个过程也可能继续进行
  - 只保证就最终值达成共识，不保证提议id
  - 节点数必须是固定的和提前知道的
  - paxos不保证所有节点都能知晓最终值

--

# 五、保证进展

- 减轻节点间干扰
  - 使用指数退避法
  - 每一个节点从一个小的重传窗口开始，比如2ms
  - 每接收到一次Nack消息就将窗口翻倍
  - 要重新提出请求消息的时候，就从0-窗口值中随机选择一个数
  - 然后延迟这么长再开始操作
- 从节点宕机中恢复
  - 从一个给定范围内随机选择超时值，超时没有接受到消息则开始自己推进
  - 这个方法降低了碰撞的可能性，并且相对数量较少的结点
  - 而指数退避法比较使用于这种场景

--

# 六、组成部分

- 提议者
  - 提出提议
  - 处理丢失和延迟的消息
  - 避免与其他的提议者的冲突
- 接受者
  - 对提议者发送来的权限请求和提议消息进行处理
  - 将已接受消息发送给仲裁者
  - 如果否定了一条消息，可以将Nack发送给该提议者
- 仲裁者
  - 接受者如果接受了一个提议，他将会把这个已接受消息发送给仲裁者
  - 如果仲裁者发现超过半数的接受者都接受了，那么（这个仲裁者就认为）就达成共识

--

# 七、常见问题

- 分布式系统的天生复杂性
  - paxos不保证全部节点学习到共识值
  - 只能对单个值形成共识
  - 大多数分布式系统并不满足于单个值的共识，因此可能使用多个paxos实例，然后在应用层对这一系列共识值进行合并
  - paxos算法本身不能保证这种思路得出的最终合并值的正确性
- 对算法的修改
  - 应尽量避免对算法的修改
  - 修改后的算法正确性未经过验证
  - 可以通过一定的模拟来实现改进
- 软件设计
  - 算法很难进行封装
  - 很难隔离网络因素
  - 应该由一小组实现核心算法的类组成
  - 可以将消息的发送和接受定义为类中的方法，则可以隔离开网络

--

# 八、Multi-Paxos

- 复制日志
  - 可以利用多个paxos实例在一组机器上实现一致的复制日志
  - 日志文件只能追加内容，如果能够保证每次追加的内容都达成了共识，那么这组机器也就有了复制日志
  - 问题:
    - 将如何防止来自不同Paxos实例的消息互相干扰？
    - 如果节点错过了一个或多个日志追加操作，它是如何检测到这一点的？
    - 节点在落后时如何迎头赶上？
    - 如何知道节点是否拥有最新的版本？
  - 答：
    - 使用文件的长度确定消息属于哪个实例
      - 如果我的文件长度比我收到的消息的文件长度短，则说明我落后了
    - 需要进行一次共识来确定哪个版本是最新的
- 复制状态机
  - 可以利用复制日志来建立复制状态机
  - 每个状态机都按照复制日志的记录顺序来执行，则状态容易保持一致
- 性能考量
  - 影响
    - 影响写入：每次写入都需要经过（至少）两次来回，一次获得批准，一次进行提议
    - 影响读取：每次想读取时不确定当前的版本，因此要进行一次共识以确定目前的版本
  - 主节点
    - 通过设置一个主节点可以避免上面的两个局限性
    - 主节点的日志一定是最新的
    - 写入时不需要进行批准，主节点直接提议即可
  - 单次往返
  - 写入优化
    - 可以将一段时间要写入的数据打包，然后进行一次共识写入
    - 减少形成共识的次数可以提高吞吐量
  - 处理单点故障
    - 为了避免主节点单点故障后整个系统完全不能工作
    - 设置主节点重选机制
    - 重选后继续进行写入和读取操作
  - 主租约
    - 主租约有时间限制
    - 到期前应不断更新租约（宣告自己存活，并继续持有租约）
  - 主租约实施方法
    - 尽量将租约实现在paxos内部，与paxos中的消息对应，而非在外部实现
  - 基于链的主租约管理
    - 链上的消息为一对值
    - 一个值为共识值（应用程序级别的值），另一个值为配置值
    - 配置值中包含了主节点的号码以及作为主节点持续的时间
    - 主节点可以在主租约到期前任意时间更改配置值
    - 其他节点只能在主租约到期后更改
  - 主租约对消息处理的限制
    - 其他节点对主节点以外的权限请求和提议消息都将丢弃
    - 保证只有主节点可以推进整个过程
    - 租约到期后将解除对消息处理的限制直到新的主节点出现
  - 主租约的时间考量
    - 绝对时间不可靠
    - 各个节点使用本地的相对时间
    - 只要主节点在发送其配置值的时候就开始计时，即可保证其计时器在其他节点计时器到期之前到期
  - 处理主节点故障
    - 选择一个新的主节点
    - 开销很大，尽量避免
    - 可以通过主节点感知到故障后自己转交主节点身份给其他节点的方式
  - 添加和删除成员
    - 更新的成员列表可以输入到paxos实例链中，所有节点使用下一个链来更新列表即可

--

# 九、Paxos变种

- Fast Paxos
  - 单次往返
  - 两种不同的轮次
  - 与传统相比，容忍的故障更少
  - 在广域网中相比Paxos并没有明显的优势
- Generalized Paxos
  - 允许条目顺序不同，只要结果状态相同即可
- Byzantine Paxos
  - 可以处理恶意节点
  - 额外的消息延迟和加密开销
- Egalitarian Paxos  
- HP Paxos
  - 混合协议
  - 结合了Classic Paxos,Fast Paxos和Generalized Paxos的优点
  
  
  
  ![paxos大纲](/images/outlineofpaxos.png)